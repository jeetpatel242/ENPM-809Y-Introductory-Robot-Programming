/**
 * @file mouse.h
 * @author Dhyey Patel (dpatel35@umd.edu), Jeet Patel (jeetp@umd.edu), Mrugesh Shah (mrugesh@umd.edu)
 * @brief The file contains the Mouse class
 * @version 0.1
 * @date 2021-11-15
 *
 * @copyright Copyright (c) 2021
 *
 */

 /*! \mainpage Maze search algorithm
  *
  * This project consists of searching a path in a maze
  * and then task a mouse (robot) to follow the path.
  * - \subpage searchingPathPage "Searching a path"
  *
  * - \subpage followingPathPage "Following a path"
  *
  */

  /*! \page searchingPathPage Searching a path
   *
   * The search algorithm used for searching a path in a maze relies on
   * the depth-first search (DFS) approach. This algorithm is implemented in rwa2::Mouse::search_maze()
   *
   */

   /*! \page followingPathPage Following a path
    *
    * To follow a path generated by DFS, methods from the class API (api/api.h) must be used to interact
    * with the micromouse simulator.
    * - Methods of the API class are documented <a href="https://github.com/mackorone/mms#summary">here</a>.
    */


#ifndef MICROMOUSE_H
#define MICROMOUSE_H

#include "../node/node.h"
#include "../util/util.h"
#include <array>
#include <stack>
#include <vector>

namespace rwa2 {
    /**
     * @brief This class is used to compute a path and execute the path.
     *
     */
    class Mouse {
        public:

        /**
         * @brief Construct a new MicroMouse object
         *
         * The robot is always at (0,0) and facing NORTH when the simulator starts
         */
        Mouse() :m_x{ 0 }, m_y{ 0 }, m_direction{ direction::NORTH } {
            //initialize the maze by placing around the perimeter of the maze
            for (int x = 0; x < m_maze_width; x += 1) {
                for (int y = 0; y < m_maze_height; y += 1) {
                    m_maze.at(x).at(y).set_wall(direction::NORTH, (y == m_maze_height - 1));
                    m_maze.at(x).at(y).set_wall(direction::EAST, (x == m_maze_width - 1));
                    m_maze.at(x).at(y).set_wall(direction::SOUTH, (y == 0));
                    m_maze.at(x).at(y).set_wall(direction::WEST, (x == 0));
                    m_maze.at(x).at(y).set_x(x);
                    m_maze.at(x).at(y).set_y(y);
                }
            }
        }
        // this method visually sets the walls in the simulator
        void display_walls();
        /**
         * @brief 
         * 
         * @param n - The current Node of the mouse in the maze
         * @param g - The goal Node for the mouse to reach
         * @param s - Stack containing the path from the initial position to the goal position
         * @param back_track - stack containing the path from the current position to the Root node from where the mouse can move if a wall is encountered in the maze
         * @param v - Contains the node visited by the mouse in the maze
         * @return true - If a path is found from initial position to goal position. 
         * @return false - If no path exist from initial position to goal position.
         */
        bool search_maze(rwa2::Node n, rwa2::Node g, std::stack<rwa2::Node>& s, std::vector<rwa2::Node>& back_track, std::vector<rwa2::Node>& v);
        /**
         * @brief Make the mouse move forward and also updates the mouse coordinates in the mouse object according to the direction the mouse is facing. 
         *
         */
        void move_forward();
        /**
         * @brief Make the mouse rotate 90 deg CCW and also updates the mouse direction in the mouse object according to the direction the mouse is facing.
         *
         */
        void turn_left();
        /**
         * @brief Make the mouse rotate 90 deg CW and also updates the mouse direction in the mouse object according to the direction the mouse is facing.
         *
         */
        void turn_right();
        /**
         * @brief Get the Current x coordinate of the mouse in the maze
         * 
         * @return int 
         */
        int get_mx();
        /**
         * @brief Get the current y coordinate of the mouse in the maze
         * 
         * @return int 
         */
        int get_my();
        /**
         * @brief Get the current direction of the mouse 
         * 
         * @return int 
         */
        int get_mdirection();
        /**
         * @brief Set the x coordinate of the mouse in the maze
         * 
         * @param mx 
         */
        void set_mx(int mx);
        /**
         * @brief Set the y coordinate of the mouse in the maze
         * 
         * @param my 
         */
        void set_my(int my);
        /**
         * @brief Set the direction of the mouse in the maze
         * 
         * @param mdirection 
         */
        void set_mdirection(int mdirection);
        /**
         * @brief Checks if a node is already present in a vector
         * 
         * @param n - Node to check
         * @param v - Vector in which we have to check 
         * @return true - If node is present in the vector
         * @return false - If node is not present in the vector
         */
        bool is_in_vector(rwa2::Node n, std::vector<rwa2::Node> v);
        /**
         * @brief Get the maze object - which returns a node which contains current mouse coordinates in the maze and the walls surrounding the node
         * 
         * @param x 
         * @param y 
         * @return rwa2::Node* 
         */
        rwa2::Node* get_maze(int x, int y);

        private:
        static const int m_maze_width{ 16 }; //width of the maze
        static const int m_maze_height{ 16 };//height of the maze
        int m_x; //x position of the robot in the maze
        int m_y; //y position of the robot in the maze
        int m_direction; //direction of the robot in the maze
        std::array<std::array<Node, m_maze_width>, m_maze_height> m_maze; //2D array maze object
    };
}
#endif
